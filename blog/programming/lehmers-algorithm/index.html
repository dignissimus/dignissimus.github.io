<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/blog/pico.min.css">
  <link rel="stylesheet" href="/blog/index.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">
  <script defer="" src="/blog/js/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>
  <script defer="" src="/blog/js/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
  <link rel="stylesheet" href="/blog/dracula.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/fortran.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/c.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/haskell.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/perl.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js"></script>
  <script>
   hljs.highlightAll();
  </script>
 </head>
 <body>
  <main>
   <h1>
    Lehmer’s algorithm
   </h1>
   <summary>
    <p>
     <strong>20 July 2023</strong>
    </p>
    <p>
     <strong>Computing the Greaest Common Divisor of multiple precision
integers</strong>
    </p>
   </summary>
   <p>
    Here, I implement greatest common divisor algorithms in C++ and
Fortran.
   </p>
   <p>
    I slowly build up to implementing Lehmer’s algorithm for calculating
the greatest common divisor on multiple precision integers and provide
my own intuition for why it works.
   </p>
   <p>
    In the future, I would like to write parallelised code for computing
the Greatest Common Divisor, utilising the algorithm of Goldreic and
Chor [4] and potentially write a GPU accelerated program in a similar
manner.
   </p>
   <hr>
   <p>
    I haven’t had much to do recently so I decided to see how fast I can
write a program to calculate the greatest common divisor of two
integers.
   </p>
   <p>
    I’ll be testing several different algorithms so it would be nice to
have a set of test cases I can use to benchmark them - I can generate
them with this script.
   </p>
   <div class="sourceCode" id="cb1">
    <pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/usr/bin/env python3</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> math</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>random.seed(<span class="dv">0</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="st">"test-cases"</span>, <span class="st">"w"</span>) <span class="im">as</span> <span class="bu">file</span>:</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, <span class="dv">21</span>):</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    number_of_bits <span class="op">=</span> <span class="dv">2</span><span class="op">**</span>i</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> test_case <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1000</span>):</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>      minimum <span class="op">=</span> <span class="dv">2</span><span class="op">**</span>(number_of_bits <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>      maximum <span class="op">=</span> <span class="dv">2</span><span class="op">**</span>number_of_bits <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>      left <span class="op">=</span> random.randint(minimum, maximum)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>      right <span class="op">=</span> random.randint(minimum, maximum)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>      <span class="bu">file</span>.write(<span class="ss">f"</span><span class="sc">{</span>left<span class="sc">}</span><span class="ss"> </span><span class="sc">{</span>right<span class="sc">}</span><span class="ss"> </span><span class="sc">{</span>math<span class="sc">.</span>gcd(left, right)<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span></code></pre>
   </div>
   <p>
    I’m generating test cases that are grouped by the number of bits the
inputs contain. I start with test cases where both numbers contain \(2^3
= 8\) bits and go upwards in powers of two until I get to \(2^{20}\) bit
integers. \(2^{n - 1}\) is the smallest integer \(n\) bit integer and
\(2^n - 1\) is the largest integer that can be made using \(n\) bits.
The <code>random.seed(0)</code> call at the top keeps things
deterministic and reproducible.
   </p>
   <p>
    I have access to a decent number of CPUs, so it would nice to split
the work across them.
   </p>
   <pre><code>#!/usr/bin/env python3
#SBATCH -t 1-0
#SBATCH --mem=128G
#SBATCH -c 128

N_EXAMPLES = 1000

import math
import random
import itertools
import multiprocessing

random.seed(0)
def generate_example(number_of_bits):
  minimum = 2**(number_of_bits - 1)
  maximum = 2**number_of_bits - 1
  left = random.randint(minimum, maximum)
  right = random.randint(minimum, maximum)
  return (left, right)

def create_testcase(example):
  left, right = example
  return left, right, math.gcd(left, right)

with open("test-cases", "w") as file:
  examples = itertools.chain.from_iterable([
      [generate_example(number_of_bits) for i in range(N_EXAMPLES)]
      for number_of_bits in [2**i for i in range(3, 21)]
  ])
  with multiprocessing.Pool(128) as pool:
    testcases = pool.imap(create_testcase, examples)
    for left, right, answer in testcases:
      file.write(f"{left} {right} {answer}\n")</code></pre>
   <p>
    Here, I create the example input in advance. I then split the task of
calculating the greatest common divisor for each of these across
different the different CPUs.
   </p>
   <p>
    For large numbers, calculating the GCD will take a while so I used
the default chunk size of 1. There are situations where it makes sense
to increase the chunk size but I don’t think there is much need here as
my program will spend much more time calculating GCDs than it will spend
on synchronisation.
   </p>
   <p>
    The <code>SBATCH</code> directives at the top are arguments to the
<code>sbatch</code> command for the Slurm workload workload manager,
which I’m using to submit jobs to the machine.
   </p>
   <h1>
    The naive algorithm
   </h1>
   <p>
    Ok, so you need to start somewhere.
   </p>
   <p>
    We know that the greatest common divisor has to be less than or equal
to smallest number so we can try every single number less than the
smaller of the two numbers and check if they’re divisible by this
number. Simple!
   </p>
   <div class="sourceCode" id="cb3">
    <pre class="sourceCode f90"><code class="sourceCode fortranfree"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">integer</span> <span class="kw">function</span> naive_gcd(left, right)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> left, right</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span> <span class="dt">::</span> smaller</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span> <span class="dt">::</span> divisor</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">logical</span> <span class="dt">::</span> divides_left, divides_right</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    naive_gcd <span class="kw">=</span> <span class="dv">1</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    smaller <span class="kw">=</span> <span class="bu">min</span>(left, right)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span> divisor <span class="kw">=</span> <span class="dv">1</span>, smaller</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        divides_left <span class="kw">=</span> <span class="bu">mod</span>(left, divisor) <span class="op">.eq.</span> <span class="dv">0</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        divides_right <span class="kw">=</span> <span class="bu">mod</span>(right, divisor) <span class="op">.eq.</span> <span class="dv">0</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> (divides_left <span class="op">.and.</span> divides_right) <span class="kw">then</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>            naive_gcd <span class="kw">=</span> divisor</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end if</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end do</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="kw">end function</span></span></code></pre>
   </div>
   <p>
    Awesome! Now, how fast is it?
   </p>
   <p>
    If the integers have \(n\) bits then we’re searching up to \(2^n\)
integers, so this is quite bad. For 8 bits we need to search 255 numbers
and for 16 bits this becomes 65535 numbers. Nowadays, integers are
normally 32 bits and we would have to search through over 4 billion
numbers. This is pretty awful.
   </p>
   <p>
    We can do a tiny bit better here. We know that any divisor of some
number \(n\) is either \(n\) itself or less than or equal to
\(\frac{n}{2}\), why?
   </p>
   <p>
    This is because if there is a number, \(d\), that divides \(n\) and
is not \(n\) itself then it must multiply with some number to make
\(n\). Since \(d\) is not \(n\), this number cannot be \(1\) so it must
be larger than or equal to 2.
   </p>
   <p>
    Let’s call this other number \(k\) so \(n = kd\) and \(k =
\frac{n}{d}\). Since \(k \geq 2\) or equivalently \(2 \leq k\), \(2 \leq
\frac{n}{d}\). Multiplying both sides by \(d\), we get \(2d \leq n\) and
\(d \leq \frac{n}{2}\). Sweet! Let’s code this up!
   </p>
   <div class="sourceCode" id="cb4">
    <pre class="sourceCode f90"><code class="sourceCode fortranfree"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">integer</span> <span class="kw">function</span> naive_gcd_half(left, right)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> left, right</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span> <span class="dt">::</span> smaller, larger</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span> <span class="dt">::</span> divisor</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">logical</span> <span class="dt">::</span> smaller_divides_larger</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">logical</span> <span class="dt">::</span> divides_left, divides_right</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    naive_gcd_half <span class="kw">=</span> <span class="dv">1</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    smaller <span class="kw">=</span> <span class="bu">min</span>(left, right)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    larger <span class="kw">=</span> <span class="bu">max</span>(left, right)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    smaller_divides_larger <span class="kw">=</span> <span class="bu">mod</span>(larger, smaller) <span class="op">.eq.</span> <span class="dv">0</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> (smaller_divides_larger) <span class="kw">then</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        naive_gcd_half <span class="kw">=</span> smaller</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end if</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span> divisor <span class="kw">=</span> <span class="dv">1</span>, smaller <span class="kw">/</span> <span class="dv">2</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        divides_left <span class="kw">=</span> <span class="bu">mod</span>(left, divisor) <span class="op">.eq.</span> <span class="dv">0</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        divides_right <span class="kw">=</span> <span class="bu">mod</span>(right, divisor) <span class="op">.eq.</span> <span class="dv">0</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> (divides_left <span class="op">.and.</span> divides_right) <span class="kw">then</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>            naive_gcd_half <span class="kw">=</span> divisor</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end if</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end do</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a><span class="kw">end function</span></span></code></pre>
   </div>
   <p>
    This code has an extra check as we need to make sure that the smaller
number isn’t the greatest common divisor before we skip it out and start
searching smaller numbers.
   </p>
   <p>
    This code is an improvement, we’re now searching \(\frac{2^n}{2} =
2^{n - 1}\) numbers. Which isn’t great but it’s definitely an
improvement.
   </p>
   <p>
    We can make another improvement here - if we know that 2 isn’t a
divisor, then we automatically know that 4, 6, 8, 10 and any other
multiple of two cannot be divisors either, so we can skip all of them!
We can repeat this for every number. This technique is called the <a href="https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">sieve of
Eratosthenes</a> and while it means we complete \(O(\log 2^n \log \log
2^n) = O(n \log n)\) operations eliminating bad candidates, this allows
us to use much fewer arithmetic operations, so this is much faster.
   </p>
   <div class="sourceCode" id="cb5">
    <pre class="sourceCode f90"><code class="sourceCode fortranfree"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">integer</span> <span class="kw">function</span> eratosthenes(left, right)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">implicit</span> <span class="kw">none</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> left, right</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span> <span class="dt">::</span> divisor</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span> <span class="dt">::</span> i</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">logical</span>, <span class="dt">dimension(:)</span>, <span class="dt">allocatable</span> <span class="dt">::</span> isnondivisor</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">allocate</span>(isnondivisor(left), source <span class="kw">=</span> <span class="cn">.false.</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    eratosthenes <span class="kw">=</span> <span class="dv">0</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> (<span class="bu">mod</span>(right, left) <span class="op">.eq.</span> <span class="dv">0</span>) <span class="kw">then</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        eratosthenes <span class="kw">=</span> left</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">return</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end if</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span> divisor <span class="kw">=</span> <span class="dv">1</span>, left <span class="kw">/</span> <span class="dv">2</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> (isnondivisor(divisor)) <span class="kw">then</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>            <span class="kw">continue</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end if</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> ((<span class="bu">mod</span>(left, divisor) <span class="op">.eq.</span> <span class="dv">0</span>) <span class="op">.and.</span> (<span class="bu">mod</span>(right, divisor) <span class="op">.eq.</span> <span class="dv">0</span>)) <span class="kw">then</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>            eratosthenes <span class="kw">=</span> divisor</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>            <span class="kw">do</span> i <span class="kw">=</span> <span class="dv">1</span>, left <span class="kw">/</span> divisor</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>                isnondivisor(i <span class="kw">*</span> divisor) <span class="kw">=</span> <span class="cn">.true.</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>            <span class="kw">end do</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end if</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end do</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a><span class="kw">end function</span></span></code></pre>
   </div>
   <h1>
    Euclid’s original algorithm
   </h1>
   <p>
    Now we can start to get a bit smart about things and take a different
approach. If we know some number, \(d\), divides both \(a\) and \(b\),
what can we say about \(b - a\). Well, \(d\) divides \(a\) so there’s
some \(k_1\) such that \(a = k_1 d\). Similarly, \(d\) divides \(b\) so
there’s some number, \(k_2\) such that \(b = k_2 d\). Using these, \(a -
b = k_1 d - k_2 d = d (k_1 - k_2)\). So, \(d\) divides \(a - b\).
   </p>
   <p>
    Why is this useful? This tells us that every number that divides both
\(a\) and \(b\) will also divide \(a - b\) so the greatest common
divisor of \(a\) and \(b\) will be the greatest common divisor of \(a\)
and \(b - a\). This is helpful because we can now search for divisors of
\(b - a\) which will be smaller than the larger of the two numbers. This
lends itself nicely to a recurisve algorithm. I will write this
iteratively because I can’t be certain that the Fortran compiler will
perform <a href="https://en.wikipedia.org/wiki/Tail_call#Implementation_methods">tail
call optimisation</a>.
   </p>
   <div class="sourceCode" id="cb6">
    <pre class="sourceCode f90"><code class="sourceCode fortranfree"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">integer</span> <span class="kw">function</span> naive_euclid(left, right)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">implicit</span> <span class="kw">none</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> left, right</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span> <span class="dt">::</span> smaller, larger</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span> <span class="dt">::</span> next</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    smaller <span class="kw">=</span> <span class="bu">min</span>(left, right)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    larger <span class="kw">=</span> <span class="bu">max</span>(left, right)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span> <span class="kw">while</span> ((smaller <span class="op">.ne.</span> <span class="dv">0</span>) <span class="op">.and.</span> (smaller <span class="op">.ne.</span> <span class="dv">1</span>))</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        next <span class="kw">=</span> larger <span class="kw">-</span> smaller</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        larger <span class="kw">=</span> <span class="bu">max</span>(smaller, next)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        smaller <span class="kw">=</span> <span class="bu">min</span>(smaller, next)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end do</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    euclid <span class="kw">=</span> larger</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="kw">end function</span></span></code></pre>
   </div>
   <p>
    This was the original algorithm presented in Euclid’s elements
   </p>
   <blockquote>
    <p>
     Let A and C be the two given positive integers; it is required to
find their greatest common divisor. If C divides A, then C is a common
divisor of C and A, since it also divides itself. And it clearly is in
fact the greatest, since no greater number than C will divide C. But if
C does not divide A, then continually subtract the lesser of the numbers
A, C from the greater, until some number is left that divides the
previous one. This will eventually happen, for if unity is left, it will
divide the previous number.
    </p>
   </blockquote>
   <p>
    At each step of iteration, I replace the larger of the two numbers,
let’s call them \(a\) and \(b\), with \(b - a\) because they all share
divisors. This is slightly better however, we perform \(O(a) = O(2^n)\)
iterations of numeric operations in the worst case which isn’t better
than what we had before.
   </p>
   <h1>
    The Euclidean algorithm
   </h1>
   <p>
    We can improve on this by noticing that we can avoid repeated
subtraction by the same number by noticing that the end result is just
the remainder after division by this number. This adjustment is quick to
make: we can just replace <code>next = larger - smaller</code> with
<code>next = mod(larger, smaller)</code>. After making this adjustment,
the code for this algorithm looks like this.
   </p>
   <div class="sourceCode" id="cb7">
    <pre class="sourceCode f90"><code class="sourceCode fortranfree"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">integer</span> <span class="kw">function</span> euclidean(left, right)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">implicit</span> <span class="kw">none</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> left, right</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span> <span class="dt">::</span> smaller, larger</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span> <span class="dt">::</span> next</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    smaller <span class="kw">=</span> <span class="bu">min</span>(left, right)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    larger <span class="kw">=</span> <span class="bu">max</span>(left, right)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span> <span class="kw">while</span> ((smaller <span class="op">.ne.</span> <span class="dv">0</span>) <span class="op">.and.</span> (smaller <span class="op">.ne.</span> <span class="dv">1</span>))</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        next <span class="kw">=</span> <span class="bu">mod</span>(larger, smaller)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        larger <span class="kw">=</span> <span class="bu">max</span>(smaller, next)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        smaller <span class="kw">=</span> <span class="bu">min</span>(smaller, next)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end do</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    euclid <span class="kw">=</span> larger</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="kw">end function</span></span></code></pre>
   </div>
   <p>
    We can show that with this adjustment we will always require fewer
than \(\log_\varphi 3a\) steps where \(\varphi\) is the <a href="https://en.wikipedia.org/wiki/Golden_ratio">golden ratio</a> but
on average we perform \(O(\log a)\) steps [1].
   </p>
   <p>
    This is significant because \(O(\log a) = O(\log 2^n) = O(n)\) so we
now have a greatest common divisor algorithm whose expected number of
steps is linear in the number of bits of our integers. If the
computational cost of arithmetic operations is proportional to the
number of bits involved, we get a complexity that scales as \(O(n^2)\).
This is neat but we can do much faster.
   </p>
   <h1>
    A binary algorithm
   </h1>
   <p>
    There’s an algorithm that’s better optimised for binary arithmetic.
It exploits the fact that for binary numbers, division by two is just a
bit-shift operation. The algorithm is based on the following
principles.
   </p>
   <ul>
    <li>
     If \(a\) and \(b\) are both even then \(\gcd(a, b) =
2\gcd(\frac{a}{2}, \frac{b}{2})\)
    </li>
    <li>
     If \(a\) is odd and \(b\) is even then \(\gcd(a, b) =
\gcd(\frac{b}{2}, a)\)
    </li>
    <li>
     If \(a\) and \(b\) are both odd then \(|a - b|\) is even and \(|a -
b| &lt; \min(a, b)\). Furthermore, \(\gcd(a, b) = \gcd(|a - b|, \min(a,
b))\)
    </li>
    <li>
     \(\gcd(a, b) = \gcd(b - a, a)\), as in Euclid’s algorithm
    </li>
   </ul>
   <p>
    With this algorithm, we can begin by dividing both \(a\) and \(b\) by
two while they are not both even and maintaining a counter, \(k\), for
how many times two divides both of them. If any of these are even, then
we can repeatedly divide this number by two, leaving the value in the
counter unmodified. We can then replace \(b\) with \(b - a\). This is my
implementation of this algorithm.
   </p>
   <div class="sourceCode" id="cb8">
    <pre class="sourceCode f90"><code class="sourceCode fortranfree"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">integer</span> <span class="kw">function</span> binary(left, right)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">implicit</span> <span class="kw">none</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> left, right</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span> <span class="dt">::</span> smaller, larger</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span> <span class="dt">::</span> next</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span> <span class="dt">::</span> k <span class="kw">=</span> <span class="dv">0</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    smaller <span class="kw">=</span> <span class="bu">min</span>(left, right)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    larger <span class="kw">=</span> <span class="bu">max</span>(left, right)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span> <span class="kw">while</span> ((<span class="bu">mod</span>(smaller, <span class="dv">2</span>) <span class="op">.eq.</span> <span class="dv">0</span>) <span class="op">.and.</span> (<span class="bu">mod</span>(larger, <span class="dv">2</span>) <span class="op">.eq.</span> <span class="dv">0</span>))</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        smaller <span class="kw">=</span> smaller <span class="kw">/</span> <span class="dv">2</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        larger <span class="kw">=</span> larger <span class="kw">/</span> <span class="dv">2</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        k <span class="kw">=</span> k <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end do</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span> <span class="kw">while</span> (smaller <span class="op">.ne.</span> <span class="dv">0</span>)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">do</span> <span class="kw">while</span> (<span class="bu">mod</span>(larger, <span class="dv">2</span>) <span class="op">.eq.</span> <span class="dv">0</span>)</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>            larger <span class="kw">=</span> larger <span class="kw">/</span> <span class="dv">2</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end do</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        <span class="kw">do</span> <span class="kw">while</span> (<span class="bu">mod</span>(smaller, <span class="dv">2</span>) <span class="op">.eq.</span> <span class="dv">0</span>)</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>            smaller <span class="kw">=</span> smaller <span class="kw">/</span> <span class="dv">2</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end do</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>       next <span class="kw">=</span> larger <span class="kw">-</span> smaller</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>       larger <span class="kw">=</span> <span class="bu">max</span>(smaller, next)</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>       smaller <span class="kw">=</span> <span class="bu">min</span>(smaller, next)</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end do</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>    binary <span class="kw">=</span> lshift(larger, k)</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a><span class="kw">end function</span></span></code></pre>
   </div>
   <p>
    This algorithm appears in a Chinese text <em>Chiu Chang Suan Shu</em>
or <em>Nine Chapters on the Mathematical Art</em> written arround 1AD.
The following excerpt describes the above algorithm.
   </p>
   <style>
    sentences p {
    margin-bottom: 0px;
}
   </style>
   <sentences>
    <blockquote>
     <p>
      If halving is possible, take half.
     </p>
     <p>
      Otherwise write down the denominator and the numerator, and subtract
the smaller from the greater.
     </p>
     <p>
      Repeat until both numbers are equal.
     </p>
     <p>
      Simplify with this common value.
     </p>
    </blockquote>
    <p>
     This algorithm also has a complexity of \(O(n^2)\) but is
significantly faster.
    </p>
   </sentences>
   <h1>
    Multiple precision arithmetic
   </h1>
   <p>
    You may have noticed that in the test cases that I generated include
numbers that contain up to \(2^{20}\) bits but the Fortran code I’ve
written uses integers, which only support numbers that use fewer than 32
bits. \(32\) is much less than \(2^{20}\) so this poses a problem as I
simply will not be able to fit the test cases into integers.
   </p>
   <p>
    It’s now time to explore multiple precision arithmetic, which will
allow me to store and operate on arbitrarily large numbers.
   </p>
   <p>
    I had lots of ideas here for building my own multi-precision
arithmetic library but, unfortunately, sense and reason got the better
of me and I decided to use a pre-existing multi-precision arithmetic
library. Which, of course, is definitely the correct thing to do albeit
a bit less fun.
   </p>
   <p>
    It’s also around here that I decide to switch to C++ - I love Fortran
but I didn’t really want to deal with trying to link libraries with
gfortran and I kept stumbling into dead links when searching for Fortran
multi-precision libraries.
   </p>
   <p>
    In C++, the binary GCD algorithm and the Euclidean algorithm look
like this using the GNU multi-precision arithmetic library.
   </p>
   <div class="sourceCode" id="cb9">
    <pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> binary<span class="op">(</span><span class="dt">mpz_t</span> result<span class="op">,</span> <span class="dt">mpz_t</span> left<span class="op">,</span> <span class="dt">mpz_t</span> right<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">mpz_t</span> smaller<span class="op">,</span> larger<span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    mpz_inits<span class="op">(</span>smaller<span class="op">,</span> larger<span class="op">,</span> <span class="kw">nullptr</span><span class="op">);</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    mpz_set<span class="op">(</span>smaller<span class="op">,</span> left<span class="op">);</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    mpz_set<span class="op">(</span>larger<span class="op">,</span> right<span class="op">);</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>mpz_cmp<span class="op">(</span>smaller<span class="op">,</span> larger<span class="op">)</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        mpz_swap<span class="op">(</span>smaller<span class="op">,</span> larger<span class="op">);</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>mpz_divisible_ui_p<span class="op">(</span>smaller<span class="op">,</span> <span class="dv">2</span><span class="op">)</span> <span class="op">&amp;&amp;</span> mpz_divisible_ui_p<span class="op">(</span>larger<span class="op">,</span> <span class="dv">2</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>k<span class="op">;</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        mpz_tdiv_q_ui<span class="op">(</span>smaller<span class="op">,</span> smaller<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        mpz_tdiv_q_ui<span class="op">(</span>larger<span class="op">,</span> larger<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>mpz_cmp_ui<span class="op">(</span>smaller<span class="op">,</span> <span class="dv">0</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>mpz_divisible_ui_p<span class="op">(</span>larger<span class="op">,</span> <span class="dv">2</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>            mpz_tdiv_q_ui<span class="op">(</span>larger<span class="op">,</span> larger<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>mpz_divisible_ui_p<span class="op">(</span>smaller<span class="op">,</span> <span class="dv">2</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>            mpz_tdiv_q_ui<span class="op">(</span>smaller<span class="op">,</span> smaller<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>        mpz_sub<span class="op">(</span>larger<span class="op">,</span> larger<span class="op">,</span> smaller<span class="op">);</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>mpz_cmp<span class="op">(</span>smaller<span class="op">,</span> larger<span class="op">)</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>            mpz_swap<span class="op">(</span>smaller<span class="op">,</span> larger<span class="op">);</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    mpz_mul_2exp<span class="op">(</span>larger<span class="op">,</span> larger<span class="op">,</span> k<span class="op">);</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    mpz_set<span class="op">(</span>result<span class="op">,</span> larger<span class="op">);</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> euclidean<span class="op">(</span><span class="dt">mpz_t</span> result<span class="op">,</span> <span class="dt">mpz_t</span> left<span class="op">,</span> <span class="dt">mpz_t</span> right<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">mpz_t</span> smaller<span class="op">,</span> larger<span class="op">;</span></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>mpz_cmp<span class="op">(</span>left<span class="op">,</span> right<span class="op">)</span> <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>        mpz_set<span class="op">(</span>smaller<span class="op">,</span> left<span class="op">);</span></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>        mpz_set<span class="op">(</span>larger<span class="op">,</span> right<span class="op">);</span></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>        mpz_set<span class="op">(</span>smaller<span class="op">,</span> right<span class="op">);</span></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>        mpz_set<span class="op">(</span>larger<span class="op">,</span> right<span class="op">);</span></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>mpz_cmp_ui<span class="op">(</span>smaller<span class="op">,</span> <span class="dv">0</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a>        mpz_mod<span class="op">(</span>larger<span class="op">,</span> larger<span class="op">,</span> smaller<span class="op">);</span></span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>mpz_cmp<span class="op">(</span>smaller<span class="op">,</span> larger<span class="op">)</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a>            mpz_swap<span class="op">(</span>smaller<span class="op">,</span> larger<span class="op">);</span></span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a>    mpz_set<span class="op">(</span>result<span class="op">,</span> smaller<span class="op">);</span></span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
   </div>
   <h1>
    Lehmer’s algorithm
   </h1>
   <p>
    Lehmer’s algorithm is a GCD algorithm for arbitrary precision
arithmetic. This is the algorithm used in the Python standard library’s
<code>gcd</code> function. Integers in python are represented using base
32, this is implemented as an array of 32-bit longs accompanied by a
number to denote size (the number of base 32 digits) and sign.
   </p>
   <p>
    The idea with Lehmer’s algorithm is to avoid multiple-precision
operations and make use of single-precision operations where possible.
We can do this after first noticing that the quotients between two
random numbers are usually small. The quotient between two random
numbers is almost always less than 1000, we can observe this
experimentally with the following program.
   </p>
   <div class="sourceCode" id="cb10">
    <pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Random</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>seed <span class="ot">=</span> mkStdGen <span class="dv">0</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="ot">generateNumbers ::</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>generateNumbers <span class="ot">=</span> <span class="fu">take</span> <span class="dv">1000</span> <span class="op">.</span> unfoldr (<span class="dt">Just</span> <span class="op">.</span> randomR (<span class="dv">0</span>, <span class="dv">2</span><span class="op">^</span><span class="dv">20</span>))</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">putStrLn</span> (<span class="fu">show</span> percentage <span class="op">++</span> <span class="st">"% of quotients were below 1000"</span>)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    (numerators, denominators) <span class="ot">=</span> generateNumbers <span class="op">***</span> generateNumbers <span class="op">$</span> split seed</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    quotients <span class="ot">=</span> <span class="fu">zipWith</span> <span class="fu">div</span> numerators denominators</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    percentage <span class="ot">=</span> <span class="dv">100</span> <span class="op">*</span> count (<span class="op">&lt;=</span><span class="dv">1000</span>) quotients <span class="ot">`div`</span> <span class="fu">length</span> quotients</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    count <span class="ot">=</span> (<span class="fu">length</span> <span class="op">.</span>) <span class="op">.</span> <span class="fu">filter</span></span></code></pre>
   </div>
   <p>
    The above reports that <code>99% of quotients were below 1000</code>.
We use this fact by approximating the quotient of two larger
multiprecision numbers as the quotient of two numbers that can be
represented using single-precision words. In fact, we take two
approximations - one approximation is an overestimate and the other is
an underestimate. Because these quotients are small, there are only a
few possibilities for the true quotient that lies between these two
bounds. In fact, about 68% of quotients are either 1, 2 or 3.
   </p>
   <p>
    We achieve these approximations by looking at the first few digits of
the number. For the case of GNU MP, these digits will be 32 bit integers
but I will use base 10 for the purpose of example.
   </p>
   <p>
    If I’d like to find the greatest common divisor of 27182818 and
10000000 using the Euclidean algorithm, I’d begin by finding the
remainder after dividing 27182818 by 10000000. I can do this by under-
and over-approximation each of these two numbers. 27182818 is
approximated as 27180000 and 27190000 and 1000000 is approximated as
10000000 and 10010000. We can thus produce an under-approximation of the
true quotient that comes out to be \(\frac{27180000}{10010000}\) and
\(\frac{27190000}{10000000}\). Clearly, these are equal to
\(\frac{2718}{1001}\) and \(\frac{2719}{1000}\) which can be computed
using single-precision division. However, using a calculator, these
quotients are both 2. So the true quotient, being bounded by these
approximations, must also be 2.
   </p>
   <p>
    Lehmer’s algorithm works by using the Eucliean algorithm on these
single-precision approximations until the quotients are no longer the
same. At this point, since we know the true quotients accumulated from
the Euclidean algorithm, we can use these quotients to perform the next
steps of the Euclidean algorithm on the multi-precision number without
ever needing to perform a multi-precision division.
   </p>
   <p>
    With the GNU MP library, each base 32 digit is stored as a 32-bit
long. These 32-bit longs are called “limbs” and have the type
<code>mp_limb_t</code>, I acess them using <code>mpz_get_limbn</code>. I
came up with the following code.
   </p>
   <div class="sourceCode" id="cb11">
    <pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> lehmer<span class="op">(</span><span class="dt">mpz_t</span> result<span class="op">,</span> <span class="dt">mpz_t</span> left<span class="op">,</span> <span class="dt">mpz_t</span> right<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">mpz_t</span> smaller<span class="op">,</span> larger<span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">mpz_t</span> smaller_prime<span class="op">,</span> larger_prime<span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    mpz_inits<span class="op">(</span>smaller<span class="op">,</span> larger<span class="op">,</span> smaller_prime<span class="op">,</span> larger_prime<span class="op">,</span> <span class="kw">nullptr</span><span class="op">);</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* under- and over-estimates of each number*/</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">mp_limb_t</span> smaller_u<span class="op">,</span> smaller_o<span class="op">,</span> larger_u<span class="op">,</span> larger_o<span class="op">;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Corresponding quotients and remainders */</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">mp_limb_t</span> q_u<span class="op">,</span> r_u<span class="op">,</span> q_o<span class="op">,</span> r_o<span class="op">;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    mpz_set<span class="op">(</span>smaller<span class="op">,</span> left<span class="op">);</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    mpz_set<span class="op">(</span>larger<span class="op">,</span> right<span class="op">);</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>mpz_cmp<span class="op">(</span>smaller<span class="op">,</span> larger<span class="op">)</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        mpz_swap<span class="op">(</span>smaller<span class="op">,</span> larger<span class="op">);</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Begin as with the Euclidean algorithm */</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>mpz_cmp_ui<span class="op">(</span>smaller<span class="op">,</span> <span class="dv">0</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>mpz_cmp<span class="op">(</span>smaller<span class="op">,</span> larger<span class="op">)</span> <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>            mpz_swap<span class="op">(</span>smaller<span class="op">,</span> larger<span class="op">);</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>mpz_cmp_ui<span class="op">(</span>smaller<span class="op">,</span> <span class="dv">0</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span><span class="op">;</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">/* Get the most significant limb from each number */</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>        smaller_u <span class="op">=</span> mpz_getlimbn<span class="op">(</span>smaller<span class="op">,</span> mpz_size<span class="op">(</span>larger<span class="op">)</span> <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>        larger_u <span class="op">=</span> mpz_getlimbn<span class="op">(</span>larger<span class="op">,</span> mpz_size<span class="op">(</span>larger<span class="op">)</span> <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>        smaller_o <span class="op">=</span> smaller_u <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>        larger_o <span class="op">=</span> larger_u <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">/*</span></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a><span class="co">         * The larger number is much larger than the smaller number</span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a><span class="co">         *  We are forced to compute a multi-precision division</span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a><span class="co">         *  This happens extremely rarely</span></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a><span class="co">         * */</span></span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>smaller_u<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>            mpz_mod<span class="op">(</span>larger<span class="op">,</span> larger<span class="op">,</span> smaller<span class="op">);</span></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>        <span class="co">// After some steps of the euclidean algorithm</span></span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a>        <span class="co">//  the two numbers become some linear combination</span></span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a>        <span class="co">//  of the original values</span></span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Use a, b to denote the coefficients</span></span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a>        <span class="co">//  for the larger and smaller number</span></span>
<span id="cb11-48"><a href="#cb11-48" aria-hidden="true" tabindex="-1"></a>        <span class="dt">mp_limb_t</span></span>
<span id="cb11-49"><a href="#cb11-49" aria-hidden="true" tabindex="-1"></a>          a_l <span class="op">=</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb11-50"><a href="#cb11-50" aria-hidden="true" tabindex="-1"></a>          b_l <span class="op">=</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb11-51"><a href="#cb11-51" aria-hidden="true" tabindex="-1"></a>          a_s <span class="op">=</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb11-52"><a href="#cb11-52" aria-hidden="true" tabindex="-1"></a>          b_s <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-53"><a href="#cb11-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-54"><a href="#cb11-54" aria-hidden="true" tabindex="-1"></a>            q_u <span class="op">=</span> larger_u <span class="op">/</span> smaller_o<span class="op">;</span></span>
<span id="cb11-55"><a href="#cb11-55" aria-hidden="true" tabindex="-1"></a>            q_o <span class="op">=</span> larger_o <span class="op">/</span> smaller_u<span class="op">;</span></span>
<span id="cb11-56"><a href="#cb11-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-57"><a href="#cb11-57" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>q_u <span class="op">!=</span> q_o<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-58"><a href="#cb11-58" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span><span class="op">(</span>a_l <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> b_l <span class="op">==</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> a_s <span class="op">==</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> b_s <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-59"><a href="#cb11-59" aria-hidden="true" tabindex="-1"></a>                    mpz_mod<span class="op">(</span>larger<span class="op">,</span> larger<span class="op">,</span> smaller<span class="op">);</span></span>
<span id="cb11-60"><a href="#cb11-60" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span><span class="op">;</span></span>
<span id="cb11-61"><a href="#cb11-61" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb11-62"><a href="#cb11-62" aria-hidden="true" tabindex="-1"></a>                mpz_mul_ui<span class="op">(</span>smaller_prime<span class="op">,</span> smaller<span class="op">,</span> a_s<span class="op">);</span></span>
<span id="cb11-63"><a href="#cb11-63" aria-hidden="true" tabindex="-1"></a>                mpz_addmul_ui<span class="op">(</span>smaller_prime<span class="op">,</span> larger<span class="op">,</span> b_s<span class="op">);</span></span>
<span id="cb11-64"><a href="#cb11-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-65"><a href="#cb11-65" aria-hidden="true" tabindex="-1"></a>                mpz_mul_ui<span class="op">(</span>larger_prime<span class="op">,</span> smaller<span class="op">,</span> a_l<span class="op">);</span></span>
<span id="cb11-66"><a href="#cb11-66" aria-hidden="true" tabindex="-1"></a>                mpz_addmul_ui<span class="op">(</span>larger_prime<span class="op">,</span> larger<span class="op">,</span> b_l<span class="op">);</span></span>
<span id="cb11-67"><a href="#cb11-67" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span><span class="op">;</span></span>
<span id="cb11-68"><a href="#cb11-68" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> </span>
<span id="cb11-69"><a href="#cb11-69" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Perform an iteration of Lehmer's algorithm</span></span>
<span id="cb11-70"><a href="#cb11-70" aria-hidden="true" tabindex="-1"></a>            r_u <span class="op">=</span> larger_u <span class="op">-</span> q_u <span class="op">*</span> smaller_o<span class="op">;</span></span>
<span id="cb11-71"><a href="#cb11-71" aria-hidden="true" tabindex="-1"></a>            r_o <span class="op">=</span> larger_o <span class="op">-</span> q_o <span class="op">*</span> smaller_u<span class="op">;</span></span>
<span id="cb11-72"><a href="#cb11-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-73"><a href="#cb11-73" aria-hidden="true" tabindex="-1"></a>            <span class="co">// This remainder is less than both of these numbers</span></span>
<span id="cb11-74"><a href="#cb11-74" aria-hidden="true" tabindex="-1"></a>            <span class="co">// The new largest number is the original smallest number</span></span>
<span id="cb11-75"><a href="#cb11-75" aria-hidden="true" tabindex="-1"></a>            <span class="co">// The new smaller number is the remainder</span></span>
<span id="cb11-76"><a href="#cb11-76" aria-hidden="true" tabindex="-1"></a>            larger_u <span class="op">=</span> smaller_o<span class="op">;</span></span>
<span id="cb11-77"><a href="#cb11-77" aria-hidden="true" tabindex="-1"></a>            larger_o <span class="op">=</span> smaller_u<span class="op">;</span></span>
<span id="cb11-78"><a href="#cb11-78" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb11-79"><a href="#cb11-79" aria-hidden="true" tabindex="-1"></a>            smaller_u <span class="op">=</span> r_u<span class="op">;</span></span>
<span id="cb11-80"><a href="#cb11-80" aria-hidden="true" tabindex="-1"></a>            smaller_o <span class="op">=</span> r_o<span class="op">;</span></span>
<span id="cb11-81"><a href="#cb11-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-82"><a href="#cb11-82" aria-hidden="true" tabindex="-1"></a>            <span class="co">// We have </span></span>
<span id="cb11-83"><a href="#cb11-83" aria-hidden="true" tabindex="-1"></a>            <span class="co">// remainder = larger - q * smaller</span></span>
<span id="cb11-84"><a href="#cb11-84" aria-hidden="true" tabindex="-1"></a>            <span class="co">// larger' = smaller</span></span>
<span id="cb11-85"><a href="#cb11-85" aria-hidden="true" tabindex="-1"></a>            <span class="co">// smaller' = remainder</span></span>
<span id="cb11-86"><a href="#cb11-86" aria-hidden="true" tabindex="-1"></a>            <span class="co">// if larger = a_l * smaller_0 + b_l * larger_0</span></span>
<span id="cb11-87"><a href="#cb11-87" aria-hidden="true" tabindex="-1"></a>            <span class="co">//    smaller = a_s * smaller_0 + b_s * larger_0</span></span>
<span id="cb11-88"><a href="#cb11-88" aria-hidden="true" tabindex="-1"></a>            <span class="co">// then</span></span>
<span id="cb11-89"><a href="#cb11-89" aria-hidden="true" tabindex="-1"></a>            <span class="co">//    smaller' = (a_l - q * a_s) * smaller_0 + (b_l - q * b_s) * larger_0</span></span>
<span id="cb11-90"><a href="#cb11-90" aria-hidden="true" tabindex="-1"></a>            <span class="co">//    larger' = a_s * smaller_0 + b_s * larger_0</span></span>
<span id="cb11-91"><a href="#cb11-91" aria-hidden="true" tabindex="-1"></a>            <span class="co">// thus</span></span>
<span id="cb11-92"><a href="#cb11-92" aria-hidden="true" tabindex="-1"></a>            <span class="co">//</span></span>
<span id="cb11-93"><a href="#cb11-93" aria-hidden="true" tabindex="-1"></a>            <span class="co">// a_s' = a_l - q * a_s</span></span>
<span id="cb11-94"><a href="#cb11-94" aria-hidden="true" tabindex="-1"></a>            <span class="co">// b_s' = b_l - q * b_s</span></span>
<span id="cb11-95"><a href="#cb11-95" aria-hidden="true" tabindex="-1"></a>            <span class="co">//</span></span>
<span id="cb11-96"><a href="#cb11-96" aria-hidden="true" tabindex="-1"></a>            <span class="co">// a_l' = a_s</span></span>
<span id="cb11-97"><a href="#cb11-97" aria-hidden="true" tabindex="-1"></a>            <span class="co">// b_l' = b_s</span></span>
<span id="cb11-98"><a href="#cb11-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-99"><a href="#cb11-99" aria-hidden="true" tabindex="-1"></a>            <span class="dt">mp_limb_t</span></span>
<span id="cb11-100"><a href="#cb11-100" aria-hidden="true" tabindex="-1"></a>              _a_l <span class="op">=</span> a_s<span class="op">,</span></span>
<span id="cb11-101"><a href="#cb11-101" aria-hidden="true" tabindex="-1"></a>              _b_l <span class="op">=</span> b_s<span class="op">;</span></span>
<span id="cb11-102"><a href="#cb11-102" aria-hidden="true" tabindex="-1"></a>            a_s <span class="op">=</span> a_l <span class="op">-</span> q_u <span class="op">*</span> a_s<span class="op">;</span></span>
<span id="cb11-103"><a href="#cb11-103" aria-hidden="true" tabindex="-1"></a>            b_s <span class="op">=</span> b_l <span class="op">-</span> q_o <span class="op">*</span> b_s<span class="op">;</span></span>
<span id="cb11-104"><a href="#cb11-104" aria-hidden="true" tabindex="-1"></a>            a_l <span class="op">=</span> _a_l<span class="op">;</span></span>
<span id="cb11-105"><a href="#cb11-105" aria-hidden="true" tabindex="-1"></a>            b_l <span class="op">=</span> _b_l<span class="op">;</span></span>
<span id="cb11-106"><a href="#cb11-106" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-107"><a href="#cb11-107" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-108"><a href="#cb11-108" aria-hidden="true" tabindex="-1"></a>    mpz_set<span class="op">(</span>result<span class="op">,</span> larger<span class="op">);</span></span>
<span id="cb11-109"><a href="#cb11-109" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre>
   </div>
   <p>
    Writing this was quite fun and seeing it work was truly awesome. I
gave it two 62 digit numbers and it returned the greatest common divisor
in under an instant. This algorithm is insanely fast but I’m not done
yet.
   </p>
   <h1>
    Parallelisation
   </h1>
   <p>
    So my code is fast, this is cool but not extraordinary. As I said,
this is the <a href="https://github.com/python/cpython/blob/a33ce66dca57d4c36b1022fdf3b7e322f3203468/Objects/longobject.c#L5317-L5522">same
algorithm that the Python math library uses</a>, although I beat Python
since my C++ is able to process the input faster using the GMP
library.
   </p>
   <p>
    I mentioned earlier that I have acess to a good number of CPU cores
so I’m obligated to use them. I was able to find two algorithms for
computing the GCD in parallel. The first <a href="https://ieeexplore.ieee.org/document/6158931">due to Brent and
Kung</a> [3] and the second due to <a href="https://link.springer.com/article/10.1007/BF01840374">Goldreich
and Chor</a> [4]. In the future, I would like to read through these
papers and implement a parallel GCD algorithm.
   </p>
   <p>
    [1]: Knuth, Donald E. “The art of computer programming. Volume 2:
Seminumerical algorithms.”
   </p>
   <p>
    [2]: Möller, Niels. “On Schönhage’s algorithm and subquadratic
integer GCD computation.” Mathematics of Computation 77.261 (2008):
589-607.
   </p>
   <p>
    [3]: R. P. Brent and H. T. Kung, “A systolic algorithm for integer
GCD computation,” 1985 IEEE 7th Symposium on Computer Arithmetic
(ARITH), Urbana, IL, USA, 1985, pp. 118-125, doi:
10.1109/ARITH.1985.6158931.
   </p>
   <p>
    [4]: Chor, B., Goldreich, O. An improved parallel algorithm for
integer GCD. Algorithmica 5, 1–10 (1990).
https://doi.org/10.1007/BF01840374
   </p>
  </main>
 </body>
</html>
