<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/blog/pico.min.css">
  <link rel="stylesheet" href="/blog/index.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
  <script src="https://unpkg.com/function-plot/dist/function-plot.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
  <link rel="stylesheet" href="/blog/dracula.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/fortran.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/c.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/haskell.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/perl.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js"></script>
  <script>
   hljs.highlightAll();
  </script>
 </head>
 <body>
  <main>
   <h1>
    Co-arrays in Fortran
   </h1>
   <summary>
    I promise I know Python and C++ and not just Fortran
   </summary>
   <br>
   <p>
    <strong>28 November 2024</strong>
   </p>
   <br>
   <p>
    <a href="https://wg5-fortran.org/N1801-N1850/N1824.pdf">Fortran 2008
introduced the concept of co-arrays</a> which, despite the name, have
nothing to do with <a href="https://en.wikipedia.org/wiki/Coinduction">coinductive
datatypes</a> also known as codata.
   </p>
   <p>
    In Fortran, co-arrays bring support for parallel programming to the
language level with the goal of making it easier to read and write
parallel code by providing a new implementation-agnostic
abstraction.
   </p>
   <p>
    You can think of co-arrays as computing the same code across
identical compute units that work on separate data. These compute units
are termed “images” and arrays in a program may be equipped with a
co-dimension which specify how to index data based on what image they
reside on.
   </p>
   <h1>
    A simple Monte Carlo simulation
   </h1>
   <p>
    For example, the following code approximates pi in parallel using a
<a href="https://en.wikipedia.org/wiki/Monte_Carlo_method">Monte
Carlo</a> simulation. In the simulation we sample points from the unit
square and approximate the area of the unit circle by considering the
proportion of these points occur in the first quadrant of the unit
circle centred around the origin.
   </p>
   <div class="sourceCode" id="cb1">
    <pre class="sourceCode fortran"><code class="sourceCode fortranfixed"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">program</span> main</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">integer</span> <span class="dt">::</span> number_of_trials <span class="kw">=</span> <span class="dv">10000000</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real(8)</span> <span class="dt">::</span> x<span class="kw">[*]</span>, y<span class="kw">[*]</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">real(8)</span> <span class="dt">::</span> total<span class="kw">[*]</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">integer</span> <span class="dt">::</span> trial_number</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">do</span> trial_number <span class="kw">=</span> <span class="dv">1</span>, number_of_trials</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">call</span> <span class="fu">random_number</span>(x)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">call</span> <span class="fu">random_number</span>(y)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> (x<span class="kw">**</span><span class="dv">2</span> <span class="kw">+</span> y<span class="kw">**</span><span class="dv">2</span> <span class="op">&lt;</span> <span class="dv">1</span>) <span class="kw">then</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        total <span class="kw">=</span> total <span class="kw">+</span> <span class="dv">1</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end if</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end do</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">call</span> co_sum(total, result_image<span class="kw">=</span><span class="dv">1</span>)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> (this_image() <span class="op">==</span> <span class="dv">1</span>) <span class="kw">then</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>      <span class="fu">print</span> <span class="kw">*</span>, <span class="st">"pi is approximately"</span>, <span class="dv">4</span> <span class="kw">*</span> <span class="dt">real(total)</span> <span class="kw">/</span> <span class="dt">real(number_of_trials)</span> <span class="kw">/</span> num_images()</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">end if</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">end program</span> main</span></code></pre>
   </div>
   <p>
    The line <code>real(8) :: x[*], y[*]</code> declares two scalar
co-arrays <code>x</code> and <code>y</code>. The code inside the square
brackets specifies the co-dimension and in particular the <code>*</code>
specifies that my images are laid out in a flat grid. Had I used
<code>x[2, *]</code> my images would be arranged in a 2 by \(n\) grid
where \(n\) is selected so that \(2n\) is larger than or equal to the
number of images at run time.
   </p>
   <p>
    The <code>co_sum</code> function sums the <code>total</code> array
across the co-dimension and the <code>result_image=1</code> argument
specifies that the result should be stored on the first image. There are
also other reduction functions for co-arrays such as <code>co_max</code>
and<code>co_min</code>.
   </p>
   <h1>
    The RBC model of the economy
   </h1>
   <p>
    Now let’s look at writing parallel programs for economics and
finance.
   </p>
   <p>
    In the typical <a href="https://en.wikipedia.org/wiki/Real_business-cycle_theory">Real
Business Cycle</a> model we have a representative household that
allocates its budget over consumption and saving to maximise a
discounted inter-temporal utility function. This means that the
household plans how much they consume and how much they save in each
time period to maximise a consumption objective while also taking into
account their budget constraint and the effects of their choices on
their own future.
   </p>
   <p>
    We formalise this as allowing the household to plan consumption
amounts \(c_t\) for every time period. We assume that the utility gained
from consumption is modelled by the <a href="https://en.wikipedia.org/wiki/Isoelastic_utility">isoelastic
utility function</a> which takes the form \(u(c_t) = \frac{c_t^{1 -
\eta}}{1 - \eta} \). Where \(\eta\) is a parameter corresponding to risk
aversion.
   </p>
   <p>
    The household then seeks to maximise time-discounted utility, which
we can interpret as valuing consumption today more than they value
consumption in the future. This time-discounted utility looks like
this
   </p>
   <p>
    \[\mathbb E_0 \sum_{t = 0}^\infty \beta^t u(c_t) \]
   </p>
   <p>
    Where \(\beta\) is termed the “discount factor”. When \(\beta\) is
less than one, the \(\beta^t\) factor decreases for each time period in
the future which has the effect of exponentially reducing the relative
weight of consumption in the future. Here \(\mathbb E_0\) refers to the
household’s expectation at the current time period \(t = 0\).
   </p>
   <p>
    The household is subject to the following budget constraint
   </p>
   <p>
    \[c_t + i_t = w_t + r_tk_t\]
   </p>
   <p>
    Where \(i_t\) refers to the amount saved at time \(t\), \(w_t\)
refers to the wage or income at time \(t\), \(r_t\) refers to the saving
rate and \(k_t\) refers to wealth at time \(t\). This constraint states
that we can only spend and save as much money as we have which is the
total amount gained from income and from existing savings.
   </p>
   <p>
    Wealth is accumulated according to following rule
   </p>
   <p>
    \[k_{t+1} = (1 - \delta) k_t + i_t\]
   </p>
   <p>
    Where \(\delta\) is a depreciation factor for wealth. This indicates
that our wealth in the next time step is equal to the sum our wealth in
the current time step accouted for depreciation and how much we save in
the current time step.
   </p>
   <p>
    In the RBC model there’s a representative firm that produces output
\(y_t = z_tk_t^\alpha\) that is a function of productivity, \(z_t\) and
capital, \(k_t\).
   </p>
   <p>
    Productivity is modelled as changing according to an AR(1)
process.
   </p>
   <p>
    \[\log z_t = \rho \log z_{t-1} + \epsilon_t\]
   </p>
   <p>
    Where \(\epsilon_t \sim \mathcal N(0, \sigma^2) \) epsilon is
stochastic white noise to add uncertainty to the simulation.
   </p>
   <p>
    We can solve this system by interpreting the household’s planning
problem using a value function \(V\) and a Bellman operator which we can
solve using value function iteration. The household’s value function
computes to the following form
   </p>
   <p>
    \[ V(k, z) = \max_c \left \{ \frac{c^{1 - \eta}}{1 - \eta} + \beta
\mathbb E\left[V(k’, z’)|z\right] \right \} \]
   </p>
   <p>
    And this is subject to the following constraint
   </p>
   <p>
    \[k’ = zk^\alpha + (1 - \delta)k - c\]
   </p>
   <p>
    Value function iteration works by first observing that a suitable
value function must satisfy \(V(x) = u(x) + \max_x \beta V(x’)\) which
is recursive in \(V\). As such we can update \(V\) using this equation
until we converge on a function.
   </p>
   <p>
    Fortran 2008 also introduced the <code>do concurrent</code> syntax
which specifies that we may perform iterations of a loop in parallel.
For simple applications like Value Function Iteration I can use
<code>do concurrent</code> without needing to use co-arrays.
   </p>
   <p>
    In my code, I first quantise my grid into a finite number of points
and then I perform value function iteration. I ignore the stochastic
factor for ease of implementation.
   </p>
   <div class="sourceCode" id="cb2">
    <pre class="sourceCode fortran"><code class="sourceCode fortranfixed"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">program</span> main   </span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">implicit</span> <span class="kw">none</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">real(8)</span>, <span class="dt">parameter</span> <span class="dt">::</span> MAX_WEALTH <span class="kw">=</span> <span class="dv">100</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">real(8)</span>, <span class="dt">parameter</span> <span class="dt">::</span> MAX_PRODUCTIVITY <span class="kw">=</span> <span class="dv">2</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">real(8)</span>, <span class="dt">parameter</span> <span class="dt">::</span> MAX_CONSUMPTION <span class="kw">=</span> <span class="dv">100</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span>, <span class="dt">parameter</span> <span class="dt">::</span> NUMBER_OF_POINTS <span class="kw">=</span> <span class="dv">100</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">real(8)</span>, <span class="dt">dimension(NUMBER_OF_POINTS, NUMBER_OF_POINTS, NUMBER_OF_POINTS)</span> <span class="dt">::</span> V</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">real(8)</span>, <span class="dt">dimension(NUMBER_OF_POINTS, NUMBER_OF_POINTS, NUMBER_OF_POINTS)</span> <span class="dt">::</span> V_prime</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span> <span class="dt">::</span> consumption_index, wealth_index, productivity_index</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">real(8)</span> <span class="dt">::</span> consumption, wealth</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">real(8)</span>, <span class="dt">parameter</span> <span class="dt">::</span> beta <span class="kw">=</span> <span class="fl">0.984</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">real(8)</span>, <span class="dt">parameter</span> <span class="dt">::</span> eta <span class="kw">=</span> <span class="dv">2</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">real(8)</span>, <span class="dt">parameter</span> <span class="dt">::</span> alpha <span class="kw">=</span> <span class="fl">0.35</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">real(8)</span>, <span class="dt">parameter</span> <span class="dt">::</span> delta <span class="kw">=</span> <span class="fl">0.01</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">real(8)</span>, <span class="dt">parameter</span> <span class="dt">::</span> rho <span class="kw">=</span> <span class="fl">0.95</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">real(8)</span>, <span class="dt">parameter</span> <span class="dt">::</span> sigma <span class="kw">=</span> <span class="fl">0.005</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span>, <span class="dt">parameter</span> <span class="dt">::</span> MAX_ITERATIONS <span class="kw">=</span> <span class="dv">200</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span> <span class="dt">::</span> iteration</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">! Simulation variables</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">integer</span>, <span class="dt">parameter</span> <span class="dt">::</span> number_of_timesteps <span class="kw">=</span> <span class="dv">10</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">real(8)</span> <span class="dt">::</span> wage <span class="kw">=</span> <span class="dv">1</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">real(8)</span> <span class="dt">::</span> interest_rate <span class="kw">=</span> <span class="fl">1.05</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">real(8)</span>, <span class="dt">dimension(number_of_timesteps)</span> <span class="dt">::</span> model_time, model_consumption, model_productivity, model_wealth</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">real(8)</span> <span class="dt">::</span> <span class="fu">epsilon</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">call</span> <span class="fu">random_number</span>(V)</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    V_prime <span class="kw">=</span> <span class="dv">0</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span> iteration <span class="kw">=</span> <span class="dv">1</span>, MAX_ITERATIONS</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>        <span class="kw">do</span> concurrent ( <span class="kw">&amp;</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>            consumption_index <span class="kw">=</span> <span class="dv">1</span>:NUMBER_OF_POINTS, <span class="kw">&amp;</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>            wealth_index <span class="kw">=</span> <span class="dv">1</span>:NUMBER_OF_POINTS, <span class="kw">&amp;</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>            productivity_index <span class="kw">=</span> <span class="dv">1</span>:NUMBER_OF_POINTS <span class="kw">&amp;</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> (consumption_index <span class="op">&gt;</span> wealth_index) <span class="kw">then</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>                <span class="kw">continue</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>            <span class="kw">end if</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>            V_PRIME(consumption_index, wealth_index, productivity_index)<span class="co"> = &amp;</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>                utility(dequantise(consumption_index, MAX_CONSUMPTION)) <span class="co">&amp;</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>                <span class="kw">+</span> beta <span class="kw">*</span> <span class="fu">maxval</span>(V(:, <span class="kw">&amp;</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>                    quantise( <span class="kw">&amp;</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>                        dequantise(productivity_index, MAX_PRODUCTIVITY)<span class="co">**rho &amp;</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">*</span> dequantise(wealth_index, MAX_WEALTH) <span class="kw">**</span> alpha <span class="co">&amp;</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">+</span> quantise((<span class="dv">1</span> <span class="kw">-</span> delta) <span class="kw">*</span> dequantise(wealth_index<span class="co">, MAX_WEALTH), MAX_WEALTH) &amp;</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">-</span> dequantise(consumption_index, MAX_CONSUMPTION)<span class="co">, &amp;</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>                        MAX_WEALTH <span class="kw">&amp;</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>                    ), <span class="kw">&amp;</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>                    quantise(dequantise(productivity_index, MAX_PRODUCTIVITY) <span class="kw">**</span> rho, MAX_PRODUCTIVITY)))</span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end do</span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>        sync <span class="fu">all</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>        <span class="kw">if</span> (this_image() <span class="op">==</span> <span class="dv">1</span>) <span class="kw">then</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>            <span class="fu">print</span> <span class="kw">*</span>, <span class="st">"iteration"</span>, iteration</span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>            V <span class="kw">=</span> V_PRIME</span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end if</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end do</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> (this_image() <span class="op">==</span> <span class="dv">1</span>) <span class="kw">then</span></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>        model_consumption(<span class="dv">1</span>) <span class="kw">=</span> <span class="dv">1</span></span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>        model_wealth(<span class="dv">1</span>) <span class="kw">=</span> <span class="dv">10</span></span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>        model_productivity(<span class="dv">1</span>) <span class="kw">=</span> <span class="dv">1</span></span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>        <span class="kw">do</span> iteration <span class="kw">=</span> <span class="dv">2</span>, number_of_timesteps</span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>            <span class="kw">call</span> <span class="fu">random_number</span>(<span class="fu">epsilon</span>)</span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>            model_time(iteration) <span class="kw">=</span> iteration</span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>            model_productivity(iteration) <span class="kw">=</span> model_productivity(iteration<span class="co"> - 1)**rho * exp(epsilon * 2 - 1)</span></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>            model_consumption(iteration) <span class="kw">=</span> dequantise( <span class="kw">&amp;</span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>                <span class="fu">maxloc</span>( <span class="kw">&amp;</span></span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>                    V(:, <span class="kw">&amp;</span></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>                        quantise(model_wealth(iteration <span class="kw">-</span> <span class="dv">1</span>), MAX_WEALTH<span class="co">), &amp;</span></span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>                        quantise(model_productivity(iteration), MAX_PRODUCTIVITY) <span class="kw">&amp;</span></span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>                    ), <span class="kw">&amp;</span></span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>                    <span class="dv">1</span> <span class="kw">&amp;</span></span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>                ), <span class="kw">&amp;</span></span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a>                MAX_CONSUMPTION <span class="kw">&amp;</span></span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a>            model_wealth(iteration) <span class="kw">=</span> <span class="kw">&amp;</span></span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a>                model_productivity(iteration <span class="kw">-</span> <span class="dv">1</span>) <span class="kw">*</span> model_wealth(iteration <span class="kw">-</span> <span class="dv">1</span>)<span class="kw">**</span>alpha <span class="kw">&amp;</span></span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a>                <span class="kw">+</span> (<span class="dv">1</span> <span class="kw">-</span> delta) <span class="kw">*</span> model_wealth(iteration <span class="kw">-</span> <span class="dv">1</span>) <span class="kw">&amp;</span></span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a>                <span class="kw">-</span> model_consumption(iteration <span class="kw">-</span> <span class="dv">1</span>) <span class="kw">+</span> wage</span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end do</span></span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a>        <span class="kw">do</span> iteration <span class="kw">=</span> <span class="dv">1</span>, number_of_timesteps</span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a>            <span class="fu">print</span> <span class="kw">*</span>, model_consumption(iteration)</span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end do</span></span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end if</span></span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a><span class="co">contains</span></span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pure</span> <span class="kw">function</span> dequantise(quantity_index, max_value)</span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a>        <span class="dt">integer</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> quantity_index</span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a>        <span class="dt">real(8)</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> max_value</span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a>        <span class="dt">real(8)</span> <span class="dt">::</span> dequantise</span>
<span id="cb2-88"><a href="#cb2-88" aria-hidden="true" tabindex="-1"></a>        dequantise <span class="kw">=</span> (quantity_index <span class="kw">-</span> <span class="dv">1</span>) <span class="kw">/</span> <span class="dt">real(NUMBER_OF_POINTS)</span> <span class="kw">*</span> <span class="dt">real(max_value)</span></span>
<span id="cb2-89"><a href="#cb2-89" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end function</span></span>
<span id="cb2-90"><a href="#cb2-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-91"><a href="#cb2-91" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pure</span> <span class="kw">function</span> clamp(x, minimum, maximum)</span>
<span id="cb2-92"><a href="#cb2-92" aria-hidden="true" tabindex="-1"></a>        <span class="dt">real(8)</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> x, minimum, maximum</span>
<span id="cb2-93"><a href="#cb2-93" aria-hidden="true" tabindex="-1"></a>        <span class="dt">real(8)</span> <span class="dt">::</span> clamp</span>
<span id="cb2-94"><a href="#cb2-94" aria-hidden="true" tabindex="-1"></a>        clamp <span class="kw">=</span> <span class="bu">min</span>(<span class="bu">max</span>(x, minimum), maximum)</span>
<span id="cb2-95"><a href="#cb2-95" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end function</span></span>
<span id="cb2-96"><a href="#cb2-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-97"><a href="#cb2-97" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pure</span> <span class="kw">function</span> quantise(quantity, max_value)</span>
<span id="cb2-98"><a href="#cb2-98" aria-hidden="true" tabindex="-1"></a>        <span class="dt">real(8)</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> quantity, max_value</span>
<span id="cb2-99"><a href="#cb2-99" aria-hidden="true" tabindex="-1"></a>        <span class="dt">integer</span> <span class="dt">::</span> quantise</span>
<span id="cb2-100"><a href="#cb2-100" aria-hidden="true" tabindex="-1"></a>        quantise <span class="kw">=</span> <span class="bu">max</span>( <span class="kw">&amp;</span></span>
<span id="cb2-101"><a href="#cb2-101" aria-hidden="true" tabindex="-1"></a>            <span class="bu">int</span>(clamp(quantity, <span class="dt">real(0, 8)</span>, max_value) <span class="kw">/</span> max_value <span class="kw">*</span> NUMBER_OF_POINTS) <span class="kw">+</span> <span class="dv">1</span>, <span class="kw">&amp;</span></span>
<span id="cb2-102"><a href="#cb2-102" aria-hidden="true" tabindex="-1"></a>            NUMBER_OF_POINTS)</span>
<span id="cb2-103"><a href="#cb2-103" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end function</span></span>
<span id="cb2-104"><a href="#cb2-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-105"><a href="#cb2-105" aria-hidden="true" tabindex="-1"></a>    <span class="kw">pure</span> <span class="kw">function</span> utility(consumption)</span>
<span id="cb2-106"><a href="#cb2-106" aria-hidden="true" tabindex="-1"></a>        <span class="dt">real(8)</span>, <span class="dt">intent(in)</span> <span class="dt">::</span> consumption</span>
<span id="cb2-107"><a href="#cb2-107" aria-hidden="true" tabindex="-1"></a>        <span class="dt">real(8)</span> <span class="dt">::</span> utility</span>
<span id="cb2-108"><a href="#cb2-108" aria-hidden="true" tabindex="-1"></a>        utility <span class="kw">=</span> consumption <span class="kw">**</span> (<span class="dv">1</span> <span class="kw">-</span> eta) <span class="kw">/</span> (<span class="dv">1</span> <span class="kw">-</span> eta)</span>
<span id="cb2-109"><a href="#cb2-109" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end function</span></span>
<span id="cb2-110"><a href="#cb2-110" aria-hidden="true" tabindex="-1"></a><span class="kw">end program</span> main</span></code></pre>
   </div>
   <p>
    I simplified the model in a few places. For example, productivity
growth is entirely deterministic and I completely removed the stochastic
factor.
   </p>
   <p>
    The VFI converges and the simulation converges to a steady state of
consumption which is good and expected however the simulation converges
unusually fast so I’ll take a closer look to figure out what’s going
on.
   </p>
   <h1>
    Pricing options
   </h1>
   <p>
    Now, I want to write some code for pricing options.
   </p>
   <p>
    In Finance, a derivative is a financial instrument whose value is
<em>derived</em> from another asset such as a stock. For example, a
forward is a financial contract that arranges the future sale of an
asset at an agreed price. An example forward contract would permit me to
purchase one share of Google (<a href="https://www.google.com/finance/quote/GOOG:NASDAQ">GOOG</a>) one
year from now at the price of $172. How much should such a contract
cost?
   </p>
   <p>
    In Finance, there’s the concept of the time value of money. It
formalises the notion of “money today is worth more than money
tommorow”. Would you rather I give you $1,000 today or $1,000 three
years from now? One intuitive reason for why this is true is that, due
to inflation, $1,000 today can buy more than $1,000 three years from
now.
   </p>
   <p>
    For example, <a href="https://onepoundsweets.com/the-hub/the-history-of-cadburys-freddo-price-rise/">I
could by 10 Freddo bars for £1 in 2000</a> however now I can only by a
measly three Freddo bars.
   </p>
   <p>
    Another intuitive reason is the interest rate and this ties in with
the demand for money. One interpretation of the interest rate is as the
answer to the question of “how much would you pay for access to money
now?”. We can see this with the <a href="https://fred.stlouisfed.org/series/FEDFUNDS">Federal Funds
Effective Rate</a> or another overnight lending rate such as <a href="https://www.bankofengland.co.uk/boeapps/database/fromshowcolumns.asp?Travel=NIxSUx&amp;FromSeries=1&amp;ToSeries=50&amp;DAT=RNG&amp;FD=1&amp;FM=Jan&amp;FY=2014&amp;TD=6&amp;TM=Dec&amp;TY=2040&amp;FNY=&amp;CSVF=TT&amp;html.x=180&amp;html.y=34&amp;C=5JK&amp;Filter=N">SONIA</a>.
   </p>
   <p>
    If a bank has an obligation that requires them to hold more money,
then they will need to purchase it for a price and this price is called
the interest rate.
   </p>
   <p>
    An interesting consequence of this interpretation is that we can use
the interest rate as a metric for stress or pressure in the financial
market. In unsecured lending markets, the interest rate tends to be
higher as the lender would like to ask for a “premium” to compensate for
the risk involved. The difference between this rate and a more secure
rate is called a spread and a high spread indicates strain or
uncertainty in the market.
   </p>
   <h2>
    Interlude
   </h2>
   <p>
    As a quick digression before going back to the time value of money,
<a href="https://en.wikipedia.org/wiki/SONIA_%28interest_rate%29">SONIA</a>
is a new interest rate average that replaced <a href="https://en.wikipedia.org/wiki/Libor">Libor</a>. Libor was
effectively a survey from banks about the rates they would lend at.
However, it was <a href="https://en.wikipedia.org/wiki/Libor_scandal">discontinued due to
fraud</a> as respondents lied abot the rates they would offer.
   </p>
   <h2>
    Interest rates, Futures and the Time Value of Money
   </h2>
   <p>
    Lets say that we have an interest rate \(r\) that is continually
compounded. So I can lend a dollar for a time period, \(t\) and at
maturity I will be owed \(e^{rt}\) dollars. Putting this in reverse, I
can effectively buy a dollar from the future for \(e^{-rt}\) dollars
today. We’re going to use this fact while pricing options.
   </p>
   <p>
    A naive attempt of pricing an option would be by considering the
expected value of the option at the time of maturity. For example, I
could construct such an option contract by waiting for a year then
purchasing the stock at the time at maturity for the agreed upon price,
this price is called the forward price.
   </p>
   <p>
    Let the forward price be \(F\), the time of maturity be \(T\) and the
stock price at the time of maturity be \(S_T\). If I use this
construction, I will make a profit of \(F - S_T\) at the time of
maturity. Adjusting for the time difference and the time value of money,
this becomes \(e^{-rT}(K - S_T)\) so this suggest that the value of this
contract is thus \(\mathbb E \left[ e^{-rT}(K - S_T) \right] \) and we
break even when this is equal to 0 which occurs when \(K = \mathbb E
\left[S_T\right]\) and the forward price is the expected price of the
stock at time \(T\).
   </p>
   <p>
    If we assume that the log-return from holding this stock, \(X \sim
N(\mu, \sigma^2)\), is normally distributed with mean \(\mu\) and
standard deviation \(\sigma\) then we get the following equation
describing the stock price.
   </p>
   <p>
    \[ \begin{align*} \log S_T &amp;= \log S_0 + X \\ S_T &amp;= S_0 e^X
\\ \end{align*} \]
   </p>
   <p>
    After integrating we get \(\mathbb E \left[ S_T \right] = S_0e^{\mu +
\frac{\sigma^2}{2}}\).
   </p>
   <p>
    However, to quote this price would be incorrect as there is an <a href="https://en.wikipedia.org/wiki/Arbitrage">arbitrage opportunity</a>
and in reality I can construct this contract cheaper.
   </p>
   <p>
    To construct this contract, I could alternatively borrow the money to
purchase this stock right now which will cost me \(S_0e^{rT}\) and
simply hold onto it until the forward contract matures and this
construction upper-bounds the fair price of this option.
   </p>
   <h2>
    Options
   </h2>
   <p>
    In Finance, a European-style option is a contract that grants the
purchaser the right to buy a stock at a specific price, the “strike
price” on a certain date. So it is like a Forward contract in that we
may buy the stock at the agreed price at the time of maturity but it
differs in that we have the <em>option</em> to not do this.
   </p>
   <p>
    If the value of the stock is higher than the contract’s strike price,
\(K\), then we can buy the stock at the strike price and sell the stock
at the market price, yielding us a profit of \(K - S_T\). If the strike
price is higher than the stock price then the contract is worthless and
our profit is 0 since it’s cheaper to buy the stock at the market price
and it doesn’t make sense to exercise our option.
   </p>
   <p>
    Using this strategy, the value of our contract at time \(T\) is
\(\max \{K - S_T, 0\}\) so the expected value of our contract now is
\(e^{-rt}\mathbb E \left[ \max \{K - S_T, 0\}\right]\).
   </p>
   <p>
    How do we calculate the expectation of the stock price? If we have a
stochastic model for how the price of our stock evolves over time then
we can evaluate it numerically by using another Monte Carlo
simulation.
   </p>
   <p>
    Recall from earlier that log returns over a fixed time period are
typically normally distributed. So we can set up a stochastic
differential equation modelling the motion of the log of stock price. If
we let \(r_t = \log S_t\) and assume <a href="https://en.wikipedia.org/wiki/Continuous_stochastic_process">continuity</a>
and <a href="https://en.wikipedia.org/wiki/Independent_increments">independent
increments</a> then if \(W_t\) is a <a href="https://en.wikipedia.org/wiki/Wiener_process">Weiner process</a>
then we have
   </p>
   <p>
    \[ dr_t = \mu dt + \sigma dW_t \]
   </p>
   <p>
    After integrating this we get \[ \begin{align*} \int_0^T dr_tdt
&amp;= \int_0^T\mu dt + \int_0^T \sigma dW_t \\ r_T &amp;= \mu T +
\sigma \int_0^T dW_t \end{align*} \]
   </p>
   <p>
    Which is an <a href="https://en.wikipedia.org/wiki/It%C3%B4_calculus#It%C3%B4_processes">Itô
process</a> that we can use Itô’s lemma with \(f(x, t) = e^x\) to
describe the motion of the stock price as an Itô process. After doing
this, we get
   </p>
   <p>
    \[ \begin{align*} dS_t &amp;= \left( \mu e^{r_t} + \frac{\sigma^2}{2}
e^{r_t} \right) dt + \sigma e^{r_t}dW_t \\ dS_t &amp;= \mu S_t
\frac{\sigma^2}{2}S_t + S_tdW_t \\ dS_t &amp;= S_t \left( \mu +
\frac{\sigma^2}{2} \right)dt + S_TdW_t \end{align*} \]
   </p>
   <p>
    This describes <a href="https://en.wikipedia.org/wiki/Geometric_Brownian_motion">Geometric
Brownian Motion</a> which we typically use to model stock prices.
   </p>
   <p>
    When I wrote my code to price options, I used a <a href="https://en.wikipedia.org/wiki/Jump_diffusion#In_economics_and_finance">Jump
diffusion</a> model which is very similar except we model the stock
price as being affected by discontinuous jumps. We model the number of
jumps occuring in a fixed period, \(N_t\), as a poisson distributed
random variable,and we model the magnitude of these jumps, \(Q_i\) as a
normally distributed random variable with constant mean and standard
deviation.
   </p>
   <p>
    Our difference equation now looks like
   </p>
   <p>
    \[ dr_T = \mu dt + \sigma dW_t + \sum_{i=1}^{N_t}Q_i \]
   </p>
   <p>
    If we make the assumption that we see at most 1 jump in a time period
or equivalently \(N_t\) is either 0 or 1 we can simplify this to
   </p>
   <p>
    \[ dr_T = \mu dt + \sigma dW_t + N_tQ_t \]
   </p>
   <p>
    Which is the sum of brownian motion and another stochastic process
that’s the combination of normally distributed random variables and
poisson distributd random variables.
   </p>
   <p>
    I again used Fortran co-arrays to write parallelised code to simulate
potential paths of the stock using the 6 cores of my laptop.
   </p>
   <p>
    I sampled from the normal distribution using the <a href="https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform">Box-Muller
transform</a> and I sample from the poisson distribution using a
technique from Knuth’s <a href="https://en.wikipedia.org/wiki/The_Art_of_Computer_Programming">The
Art of Computer Programming</a>.
   </p>
   <p>
    I list some example price paths from my simulation below. In the
second image I increase the expected jump size to better illustrate the
jump diffusion model.
   </p>
   <p>
    <img src="/blog/images/more-simulated-asset-prices-jump-model.png" alt="Simulated Jump Diffusion Stock Prices">
   </p>
   <p>
    <img src="/blog/images/simulated-asset-prices-jump-model.png" alt="Simulated Jump Diffusion Stock Prices">
   </p>
   <p>
    My code looks like this
   </p>
   <pre><code>program main
    implicit none
    ! Initial stock price
    real(8), parameter :: S0 = 100
    ! Strike price
    real(8), parameter :: K = 110
    ! Time to maturity in years
    real(8), parameter :: T = 1
    ! Risk free rate
    real(8), parameter :: r = 0.02
    ! Volatility
    real(8), parameter :: volatility = 0.2
    ! Number of jumps per year
    real(8), parameter :: expected_number_of_jumps = 2
    ! Mean jump size
    real(8), parameter :: mean_jump_size = 0
    ! Jump size standard deviation
    real(8), parameter :: jump_volatility = 0.3

    integer, parameter :: number_of_simulations = 1
    integer, parameter :: number_of_timesteps = 1000
    real(8), parameter :: dt = T / number_of_timesteps
    real(8), dimension(number_of_timesteps, number_of_simulations) :: S[*]
    real(8), dimension(number_of_timesteps, number_of_simulations) :: W1[*], W2[*]
    real(8), dimension(number_of_timesteps, number_of_simulations) :: poisson, brownian_motion
    integer :: simulation, iteration
    integer :: image

    do simulation = 1, number_of_simulations
        do iteration = 1, number_of_timesteps
                poisson(iteration, simulation) = rpoisson(expected_number_of_jumps * dt) * rnorm(mean_jump_size, jump_volatility)
                brownian_motion(iteration, simulation) = &amp;
                    ( &amp;
                        r &amp;
                        - (volatility**2 - expected_number_of_jumps * (mean_jump_size + jump_volatility ** 2)) / 2 &amp;
                    ) * dt &amp;
                    + volatility * sqrt(dt) * rnorm(0.d0, 1.d0)
        end do
    end do

    do iteration = 2, number_of_timesteps
        poisson(iteration, :) = poisson(iteration - 1, :) + poisson(iteration, :)
        brownian_motion(iteration, :) = brownian_motion(iteration - 1, :) + brownian_motion(iteration, :)
    end do


    S = S0 * exp(brownian_motion + poisson)
    sync all
    if (this_image() .eq. 1) then
        do image = 1, num_images()
            print *, S(:, 1)[image]
        end do
    end if
contains
    function runiform()
        real(8) :: runiform
        call random_number(runiform)
    end function
    function rnorm(mu, sigma)
        ! Box-muller transform
        real(8) :: rnorm
        real(8) :: u1, u2
        real(8) :: pi = 4.d0 * atan(1.d0)
        real(8) :: mu, sigma
        call random_number(u1)
        call random_number(u2)
        rnorm = mu + sigma * sqrt(-2 * log(u1)) * cos(2 * pi * u2)
    end function
    function rpoisson(lambda)
        real(8) :: rpoisson
        real(8), intent(in) :: lambda
        real(8) :: exp_lambda, uniform_product
        threshold = exp(-lambda)
        rpoisson = -1
        uniform_product = 1
        do while (threshold &lt; uniform_product)
            uniform_product = uniform_product * runiform()
            rpoisson = rpoisson + 1
        end do
    end function rpoisson
end program main</code></pre>
   <p>
    Pricing options now just becomes a case of taking an average of
\(\max\{S_T, 0\}\) over all the generated paths.
   </p>
   <p>
    This was a pretty fun project.
   </p>
   <h1>
    References
   </h1>
   <p>
    [1]: Fernández-Villaverde, Jesús, and David Zarruk Valencia. A
practical guide to parallelization in economics. No. w24561. National
Bureau of Economic Research, 2018.
   </p>
   <p>
    [2]: Aldrich, Eric M., et al. “Tapping the supercomputer under your
desk: Solving dynamic equilibrium models with graphics processors.”
Journal of Economic Dynamics and Control 35.3 (2011): 386-393.
   </p>
   <p>
    [3]: Peng, Ying, et al. “Parallel computing for option pricing based
on the backward stochastic differential equation.” High Performance
Computing and Applications: Second International Conference, HPCA 2009,
Shanghai, China, August 10-12, 2009, Revised Selected Papers. Springer
Berlin Heidelberg, 2010.
   </p>
   <p>
    [4]: Baxter, Martin, and Andrew Rennie. Financial calculus: an
introduction to derivative pricing. Cambridge university press,
1996.
   </p>
   <p>
    [5]: Merton, Robert C. “Option pricing when underlying stock returns
are discontinuous.” Journal of financial economics 3.1-2 (1976):
125-144.
   </p>
   <p>
    [6]: Knuth, Donald E. The Art of Computer Programming: Seminumerical
Algorithms, Volume 2. Addison-Wesley Professional, 2014.
   </p>
  </main>
 </body>
</html>
