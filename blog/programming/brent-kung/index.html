<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/blog/pico.min.css">
  <link rel="stylesheet" href="/blog/index.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css" integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ" crossorigin="anonymous">
  <script defer="" src="/blog/js/katex.min.js" integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY" crossorigin="anonymous"></script>
  <script defer="" src="/blog/js/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
  <link rel="stylesheet" href="/blog/dracula.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/go.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/fortran.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/cpp.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/julia.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/c.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/haskell.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/perl.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/rust.min.js"></script>
  <script type="text/javascript" src="https://unpkg.com/highlightjs-lean/dist/lean.min.js"></script>
  <script type="text/javascript" src="https://unpkg.com/highlightjs-lean/dist/r.min.js"></script>
  <script>
   hljs.highlightAll();
  </script>
 </head>
 <body>
  <main>
   <h1>
    Implementing the Brent-Kung addition circuit in hardware
   </h1>
   <p>
    <strong>13 September 2025</strong>
   </p>
   <hr>
   <p>
    Recently I’ve been doing the <a href="https://hdlbits.01xz.net/">HDLBits</a> Verilog exercises; there’s
about 200 of them but one in particular piqued my interest.
   </p>
   <p>
    The exercise titled <a href="https://hdlbits.01xz.net/wiki/Adder100">Adder100</a> asks you to
create a 100-bit addition circuit that handles both carry in and carry
out. I remembered that there is an algorithm for parallel addition that
falls in thes <a href="https://wikipedia.org/wiki/AC0">AC0</a>
complexity class.
   </p>
   <p>
    AC0 is the complexity class for circuits of constant depth with
respect to the size of the input where each logic gate in the circuit
has polynomial fan in. That means every logic gate like AND has its
number of inputs bounded by a polynomial function of the input size. So
saying addition is in AC0 means we can we only need a constant number of
logic gates provided each logic gate can accept a reasonable number of
inputs.
   </p>
   <p>
    The algorithm itself isn’t very complicated and is pretty much the
same as how we’re taught to add number in school.
   </p>
   <p>
    Take for example the binary numbers <code>1010</code> and
<code>1011</code>. We add the numbers in each of the digit positions
like in the diagram below where we know the following rules for binary
addition
   </p>
   <ul>
    <li>
     \(0 + 0 = 0\)
    </li>
    <li>
     \(0 + 1 = 1\)
    </li>
    <li>
     \(1 + 0 = 1\)
    </li>
    <li>
     \(1 + 1 = 10\)
    </li>
   </ul>
   <p>
    All of these additions produce one digit except the rule for \(1 +
1\) which produces two digits. If we didn’t have the case where both of
the summand digits were 1 then we could find digits for the sum by
simply adding the digits in the same position.
   </p>
   <p>
    This doesn’t work in general because \(1 + 1\) generates a ‘carry’
bit which we need to add to the next digit, just like when we did
addition in school. Visually that looks like this
   </p>
   <p>
    <img src="/blog/images/brent-kung/high-school-summation.svg">
   </p>
   <p>
    When we need to add two one bits together, we set the carry bit of
the next digit to 1. And, once we’ve calculated the carry bits we can
add the three digits together in a similar way.
   </p>
   <p>
    If the carry bit is 0 then we add the numbers as we usually would
since adding 0 doesn’t change a number.
   </p>
   <p>
    If, however, the carry bit is 1 then we have new addition rules
   </p>
   <ul>
    <li>
     \(1 + 0 + 0 = 1\)
    </li>
    <li>
     \(1 + 0 + 1 = 10\)
    </li>
    <li>
     \(1 + 1 + 0 = 10\)
    </li>
    <li>
     \(1 + 1 + 1 = 11\)
    </li>
   </ul>
   <p>
    Most of these generate a carry! However, this is ok as we can
continue this procedure of adding and generating carry bits until we
don’t have a carry anymore.
   </p>
   <p>
    The addition rules for the sum bit simplifies to just the xor of the
bits we’re adding. So \(1 + 0 + 1\) has a sum bit of \(1 \oplus 0 \oplus
1 = 0\).
   </p>
   <p>
    The rule for determining the carry is a bit different. I introduced
it earlier by iteratively adding digits and moving the carry bit to the
next place. However, we can think about it in a different way and look
at a specific position then ask “when will the carry bit for this
position be 1?”.
   </p>
   <p>
    We do this by thinking about “generating” and “propagating” carry
bits. This works by noticing that for 2 digit summation we only have a
carry bit when both of the summands bits are 1. In SystemVerilog we can
test that for a position using <code>a[j] &amp; b[j]</code> which
evaluates to true when both <code>a</code> and <code>b</code> have 1
bits at position <code>j</code>.
   </p>
   <p>
    Even though a certain bit generates a carry bit, we need to ask if it
makes it way to the position we care about. For example, the carry
generated by the 1 + 1 addition makes its way to the final position
following example
   </p>
   <p>
    <img src="/blog/images/brent-kung/propagate.svg">
   </p>
   <p>
    When looking at the carry bit for a certain position we can look at
all generator bits in front of it and check if the digits in between
allow it to propagate onwards. Looking at our addition rules, we can
propagate an carry 1 bit as long as we have at least one of our summand
bits is a 1. In SystemVerilog we can test this using
<code>a[i] | b[i]</code>.
   </p>
   <p>
    in SystemVerilog that looks like this
   </p>
   <div class="sourceCode" id="cb1">
    <pre class="sourceCode sv"><code class="sourceCode systemverilog"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> top_module #(</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">parameter</span> BITS = <span class="dv">4</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>(</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">input</span> <span class="kw">logic</span> [BITS - <span class="dv">1</span> : <span class="dv">0</span>] a,</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">input</span> <span class="kw">logic</span> [BITS - <span class="dv">1</span> : <span class="dv">0</span>] b,</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">input</span> <span class="kw">logic</span> cin,</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">output</span> <span class="kw">logic</span> [BITS - <span class="dv">1</span> : <span class="dv">0</span>] <span class="ot">sum</span>,</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">output</span> <span class="kw">logic</span> cout</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>);</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">logic</span> [BITS - <span class="dv">1</span> : <span class="dv">0</span>] carry;</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assign</span> carry[<span class="dv">0</span>] = cin;</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">genvar</span> i, j, k;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">generate</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">for</span> (i = <span class="dv">1</span>; i &lt; BITS; i++) <span class="kw">begin :</span><span class="dt"> </span><span class="kw">loop</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>      <span class="kw">logic</span> [i - <span class="dv">1</span> : <span class="dv">0</span>] or_reduction;</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>      <span class="kw">for</span> (j = <span class="dv">0</span>; j &lt; i; j++) <span class="kw">begin :</span><span class="dt"> </span><span class="kw">loop2</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">logic</span> [i - <span class="dv">1</span> : j] does_generate;</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        <span class="kw">assign</span> does_generate[j] =</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>                (j == <span class="dv">0</span>) ?</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>                (a[<span class="dv">0</span>] &amp; b[<span class="dv">0</span>] | a[<span class="dv">0</span>] &amp; cin | b[<span class="dv">0</span>] &amp; cin)</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>                : a[j] &amp; b[j];</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        <span class="kw">for</span> (k = j + <span class="dv">1</span>; k &lt; i; k++) <span class="kw">begin :</span><span class="dt"> </span><span class="kw">loop3</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>          <span class="kw">assign</span> does_generate[k] = a[k] | b[k];</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        <span class="kw">end</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        <span class="kw">assign</span> or_reduction[j] = &amp;does_generate;</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>      <span class="kw">end</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>      <span class="kw">assign</span> carry[i] = |or_reduction;</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">end</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">endgenerate</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assign</span> <span class="ot">sum</span> = a ^ b ^ carry;</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>  <span class="kw">assign</span> cout = a[BITS - <span class="dv">1</span>] &amp; b[BITS - <span class="dv">1</span>] | carry[BITS - <span class="dv">1</span>] &amp; a[BITS - <span class="dv">1</span>] | carry[BITS - <span class="dv">1</span>] &amp; b[BITS - <span class="dv">1</span>];</span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="kw">endmodule</span></span></code></pre>
   </div>
   <p>
    As a circuit it looks like this
   </p>
   <p>
    <img src="/blog/images/brent-kung/initial-circuit.png">
   </p>
   <p>
    However there’s a massive problem. In hardware we don’t have
polynomial fan in: we have a fan-in of 2 so we can’t compute the chain
of ANDs and ORs in one step which means this circuit doesn’t have
constant depth. In fact this circuit has a pretty bad \(O(n)\) depth and
\(O(n^2)\) gates.
   </p>
   <p>
    It’s not that awful though, we can speed up my circuit by computing
the AND and OR chain in parallel in a similar way to how you would do a
parallel tree reduction in MPI. There’s pseudocode for this on the
wikipedia page for the <a href="https://en.wikipedia.org/wiki/Brent%E2%80%93Kung_adder">Brent-Kung
adder</a>.
   </p>
   <pre><code>module top_module #(
  parameter BITS = 4
)(
  input logic [BITS - 1 : 0] a,
  input logic [BITS - 1 : 0] b,
  input logic cin,
  output logic [BITS - 1 : 0] sum,
  output logic cout
);

  logic [BITS - 1 : 0] g, p;
  assign g = a &amp; b;
  assign p = a | b;

  logic [BITS - 1 : 0] G [$clog2(BITS) : 0];
  logic [BITS - 1 : 0] P [$clog2(BITS) : 0];
  assign G[0] = g;
  assign P[0] = p;

  logic [BITS : 0] carry;
  assign carry[0] = cin;

  genvar step, i, j;
  generate
    for (step = 1; step &lt;= $clog2(BITS); step++) begin : loop
      for (i = 0; i &lt; BITS; i++) begin : loop2
        if (i &lt; (1 &lt;&lt; (step - 1))) begin
          assign G[step][i] = G[step - 1][i];
          assign P[step][i] = P[step - 1][i];
        end else begin
          assign G[step][i] = G[step - 1][i] | (P[step - 1][i] &amp; G[step -1][i - (1 &lt;&lt; (step - 1))]);
          assign P[step][i] = P[step - 1][i] &amp; P[step - 1][i - (1 &lt;&lt; (step - 1))];
        end
      end
    end
    for (i = 1; i &lt; BITS + 1; i++) begin : loop3
      assign carry[i] = G[$clog2(BITS)][i - 1] | (P[$clog2(BITS)][i - 1] &amp; cin);
    end
  endgenerate

  assign sum  = a ^ b ^ carry[BITS - 1 : 0];
  assign cout = carry[BITS];
endmodule</code></pre>
   <p>
    This looks like this as a circuit
   </p>
   <p>
    <img src="/blog/images/brent-kung/brent-kung.png">
   </p>
   <p>
    I wrote a small cocotb test bench for this
   </p>
   <div class="sourceCode" id="cb3">
    <pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> cocotb</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> cocotb.triggers <span class="im">import</span> Timer</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="at">@cocotb.test</span>()</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="cf">async</span> <span class="kw">def</span> test(dut):</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  BITS <span class="op">=</span> <span class="bu">len</span>(dut.a)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> a <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span><span class="op">**</span>(BITS <span class="op">-</span> <span class="dv">1</span>)):</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> b <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span> <span class="op">**</span> (BITS <span class="op">-</span> <span class="dv">1</span>)):</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> cin <span class="kw">in</span> [<span class="dv">0</span>, <span class="dv">1</span>]:</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        dut.a.value <span class="op">=</span> a</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        dut.b.value <span class="op">=</span> b</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        dut.cin.value <span class="op">=</span> cin</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">await</span> Timer(<span class="dv">1</span>, units<span class="op">=</span><span class="st">"ns"</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        actual_sum  <span class="op">=</span> <span class="bu">int</span>(dut.<span class="bu">sum</span>.value)</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        actual_cout <span class="op">=</span> <span class="bu">int</span>(dut.cout.value)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        real_sum <span class="op">=</span> a <span class="op">+</span> b <span class="op">+</span> cin</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        expected_sum  <span class="op">=</span> real_sum <span class="op">&amp;</span> (<span class="dv">2</span> <span class="op">**</span> BITS <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        expected_cout <span class="op">=</span> (real_sum <span class="op">&gt;&gt;</span> BITS) <span class="op">&amp;</span> <span class="dv">1</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> actual_sum <span class="op">==</span> expected_sum, <span class="ss">f"</span><span class="sc">{</span>a<span class="sc">}</span><span class="ss"> + </span><span class="sc">{</span>b<span class="sc">}</span><span class="ss"> + </span><span class="sc">{</span>cin<span class="sc">}</span><span class="ss">: expected </span><span class="sc">{</span>expected_sum<span class="op">=</span><span class="sc">}</span><span class="ss"> but got </span><span class="sc">{</span><span class="bu">sum</span><span class="op">=</span><span class="sc">}</span><span class="ss">"</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">assert</span> actual_cout <span class="op">==</span> expected_cout, <span class="ss">f"</span><span class="sc">{</span>a<span class="sc">}</span><span class="ss"> + </span><span class="sc">{</span>b<span class="sc">}</span><span class="ss"> + </span><span class="sc">{</span>cin<span class="sc">}</span><span class="ss">: expected </span><span class="sc">{</span>expected_cout<span class="op">=</span><span class="sc">}</span><span class="ss"> but got </span><span class="sc">{</span>cout<span class="op">=</span><span class="sc">}</span><span class="ss">"</span></span></code></pre>
   </div>
   <p>
    It needs a Makefile and there’s a guide in the <a href="https://docs.cocotb.org/en/stable/quickstart.html">cocotb
documentation</a>
   </p>
   <div class="sourceCode" id="cb4">
    <pre class="sourceCode Makefile"><code class="sourceCode makefile"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">SIM</span> <span class="ch">=</span><span class="st"> verilator</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="dt">TOPLEVEL_LANG</span> <span class="ch">=</span><span class="st"> verilog</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="dt">VERILOG_SOURCES</span> <span class="ch">=</span><span class="st"> ../parallel-adder.sv</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="dt">COCOTB_TEST_MODULES</span> <span class="ch">=</span><span class="st"> test</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="dt">TOPLEVEL</span> <span class="ch">=</span><span class="st"> top_module</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">include</span> <span class="ch">$(</span><span class="kw">shell</span><span class="st"> cocotb-config --makefiles</span><span class="ch">)</span>/Makefile.sim</span></code></pre>
   </div>
   <p>
    By default cocotb uses iverilog but I changed it to verilator since
that’s what I have installed on my laptop.
   </p>
   <p>
    I had to use <code> /* verilator lint_off UNOPTFLAT */</code> pragmas
to get it to work, I don’t understand why though.
   </p>
   <p>
    After doing this I ran <code>make</code> and my tests all passed.
   </p>
   <p>
    However, I’ve overcomplicated this and the site accepts the following
solution
   </p>
   <div class="sourceCode" id="cb5">
    <pre class="sourceCode sv"><code class="sourceCode systemverilog"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> top_module( </span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">input</span> [<span class="dv">99</span>:<span class="dv">0</span>] a, b,</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">input</span> cin,</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">output</span> cout,</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">output</span> [<span class="dv">99</span>:<span class="dv">0</span>] <span class="ot">sum</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>);</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">assign</span> {cout, <span class="ot">sum</span>} = a + b + cin;</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="kw">endmodule</span></span></code></pre>
   </div>
   <p>
    Even still, this was a fun exploration!
   </p>
  </main>
 </body>
</html>
